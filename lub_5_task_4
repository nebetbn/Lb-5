#include <iostream>
#include <vector>
#include <string>
#include <algorithm> // Для std::min, std::reverse

const long long INF = 1e18; // Використовуємо велике число для представлення "нескінченності"

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    std::string s1, s2;
    std::cin >> s1 >> s2;

    int len1 = s1.length();
    int len2 = s2.length();

    // dp[i][j] буде зберігати мінімальну довжину рядка,
    // що задовольняє s1[0...i-1] та s2[0...j-1].
    std::vector<std::vector<long long>> dp(len1 + 1, std::vector<long long>(len2 + 1, INF));

    // Матриця для відновлення шляху
    // 0: не визначено, 1: збіг (діагональ), 2: s1 просунувся (*), 3: s2 просунувся (*)
    // 4: s1[*] спожив порожнє, 5: s2[*] спожив порожнє
    std::vector<std::vector<int>> path(len1 + 1, std::vector<int>(len2 + 1, 0));


    // Базовий випадок: порожні префікси обох шаблонів відповідають порожньому рядку довжини 0.
    dp[0][0] = 0;

    // Ініціалізація для випадків, коли один з шаблонів починається з зірочок
    // (зірочка може відповідати порожньому рядку)
    for (int i = 1; i <= len1; ++i) {
        if (s1[i-1] == '*') {
            if (dp[i-1][0] != INF) {
                dp[i][0] = dp[i-1][0];
                path[i][0] = 4; // '*' в s1 відповідає порожньому рядку
            }
        } else { // Якщо не '*', то не може відповідати порожньому рядку
            dp[i][0] = INF;
        }
    }
    for (int j = 1; j <= len2; ++j) {
        if (s2[j-1] == '*') {
            if (dp[0][j-1] != INF) {
                dp[0][j] = dp[0][j-1];
                path[0][j] = 5; // '*' в s2 відповідає порожньому рядку
            }
        } else { // Якщо не '*', то не може відповідати порожньому рядку
            dp[0][j] = INF;
        }
    }


    // Заповнення таблиці DP
    for (int i = 0; i <= len1; ++i) {
        for (int j = 0; j <= len2; ++j) {
            if (dp[i][j] == INF) {
                continue; // Якщо поточний стан недосяжний, пропускаємо
            }

            // Варіант 1: Обидва шаблони споживають символ
            // (Літера/літера, Літера/?, ?/Літера, ?/?, Зірка/літера, Літера/зірка, Зірка/зірка)
            if (i < len1 && j < len2) {
                char char1 = s1[i];
                char char2 = s2[j];

                bool match = false;
                if (char1 == '*' || char2 == '*') {
                    // Якщо хоча б одна зірка, вони можуть збігтися з одним символом
                    // *A, B* => C
                    // *A, *B => C
                    match = true;
                } else if (char1 == '?' || char2 == '?') {
                    // Якщо хоча б один '?', вони можуть збігтися
                    match = true;
                } else if (char1 == char2) {
                    // Якщо літери однакові
                    match = true;
                }

                if (match) {
                    if (dp[i][j] + 1 < dp[i+1][j+1]) {
                        dp[i+1][j+1] = dp[i][j] + 1;
                        path[i+1][j+1] = 1; // Обидва споживають символ (діагональний рух)
                    }
                }
            }

            // Варіант 2: s1[i] є '*' і він відповідає порожньому рядку
            if (i < len1 && s1[i] == '*') {
                if (dp[i][j] < dp[i+1][j]) { // '*' в s1 відповідає порожньому рядку
                    dp[i+1][j] = dp[i][j];
                    path[i+1][j] = 4; // '*' в s1 відповідає порожньому рядку
                }
            }

            // Варіант 3: s2[j] є '*' і він відповідає порожньому рядку
            if (j < len2 && s2[j] == '*') {
                if (dp[i][j] < dp[i][j+1]) { // '*' в s2 відповідає порожньому рядку
                    dp[i][j+1] = dp[i][j];
                    path[i][j+1] = 5; // '*' в s2 відповідає порожньому рядку
                }
            }
        }
    }

    long long result_len = dp[len1][len2];
    if (result_len == INF) {
        std::cout << -1 << "\n";
    } else {
        std::string result_str = "";
        int cur_i = len1;
        int cur_j = len2;

        while (cur_i >
